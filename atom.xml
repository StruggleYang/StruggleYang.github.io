<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>StruggleYang</title>
  
  <subtitle>秋天该很好，你若尚在场！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://git66.com/"/>
  <updated>2018-03-12T06:55:47.626Z</updated>
  <id>http://git66.com/</id>
  
  <author>
    <name>StruggleYang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>领域事件及事件总线EventBus使用实践</title>
    <link href="http://git66.com/2018/03/10/DDD-event-bus/"/>
    <id>http://git66.com/2018/03/10/DDD-event-bus/</id>
    <published>2018-03-10T15:49:49.000Z</published>
    <updated>2018-03-12T06:55:47.626Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://github.com/dapeng-soa" target="_blank" rel="noopener">@大鹏开源</a>:别看我有点萌，我可以秒变大鹏😄</p></blockquote><p><img src="http://oqr3htxnb.bkt.clouddn.com/18-3-10/59987509.jpg" alt=""></p><h2 id="DDD-与领域事件"><a href="#DDD-与领域事件" class="headerlink" title="DDD 与领域事件"></a>DDD 与领域事件</h2><blockquote><p>在过去的 30 多年，就已经有领域建模和设计的思潮；Eric Evans 将其定义为领域驱动设计（Domain-Driven Design，简称DDD）。领域模型是领域驱动的核心，而领域事件又作为领域模型中的重要模块，解决了开发者日常开发中的很多痛点，比如，代码藕合降低，拓展性增强。</p></blockquote><p>领域模型不是高大上的东西，所有的领域模型抽象都来自于具体的业务及业务的需求,而脱离业务需求的应用设计是没有任何价值的！</p><p>比如在Today的新零售电商架构中:门店、采购、订单、供应商、物流、商品、台账等等都是应用设计中的不同领域模型，必然还存在或多或少的子域模型。而对于技术人员来说，这些抽象出来的领域，就代表应用架构存在若干子系统。</p><p>系统与系统间，势必会存在某些关联。比如说A领域“发生某件事情”、“当什么产生变化的时候”、“如果什么状态变更”…，都将可能成为B领域所要关心的事件。</p><a id="more"></a><h2 id="事件总线的大体流程"><a href="#事件总线的大体流程" class="headerlink" title="事件总线的大体流程"></a>事件总线的大体流程</h2><ul><li><p>在这里发出事件通知的一方称为发送者 (Publisher) ,关心事件的一方称为订阅者 (Subscriber)。</p></li><li><p>关心一件事，便会收集这件事情相关的信息。而这些都将会转换为消息流，在订阅这件事情的领域间传播，一旦命中所要关心的事情，就由订阅者自行去处理接下来的事情。</p></li></ul><p><img src="http://oqr3htxnb.bkt.clouddn.com/18-3-12/24835978.jpg" alt=""><br>以上eventbus示意图大致流程是这样的：</p><ul><li>服务接口触发事件</li><li>eventbus 分发事件，如果存在领域内订阅者，直接分发到指定订阅者，再将事件消息存库定时发送至 kafka</li><li>如果不存在领域内订阅者，事件消息直接存库并定时发送 kafka</li><li>消息在发送成功以后会被清除，为了保证事务的一致性。建议事件db共享业务数据源</li><li>订阅者只需要订阅事件双方规约好的 topic 和事件类型就可以命中需要的事件消息</li></ul><h2 id="为什么要引入事件"><a href="#为什么要引入事件" class="headerlink" title="为什么要引入事件"></a>为什么要引入事件</h2><p>在代码中通常这样去描述针对某些状态对应做什么事。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">code <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span> =&gt; </span><br><span class="line">        <span class="comment">// do A</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span> =&gt; </span><br><span class="line">        <span class="comment">// do B</span></span><br><span class="line">    <span class="keyword">case</span> _ =&gt; </span><br><span class="line">        <span class="comment">// do ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当遇到某个状态，需要第三方系统作出应对，开发者可能不是那么愿意为此去加入冗长的代码甚至引入别人的 api ，而这与当前领域相关性也不会太大。领域事件帮助开发者更加优雅的解决了这个问题！</p><blockquote><p>do A 就变成了 do event_A</p></blockquote><h4 id="降低耦合，高拓展性"><a href="#降低耦合，高拓展性" class="headerlink" title="降低耦合，高拓展性"></a>降低耦合，高拓展性</h4><ul><li>事件对于触发的一方来说只是一个函数，而不再是一大堆的业务逻辑，将这些与领域解藕，让业务系统只关心业务！</li><li>如果发送方需要发送更多的事件，只需要触发更多的方法即可；对于订阅者来说，可以订阅任何领域发过来的事件消息</li></ul><h4 id="高复用性"><a href="#高复用性" class="headerlink" title="高复用性"></a>高复用性</h4><ul><li>事件可能只需要做一次，而发送者与订阅者是 1:N 的，一个事件可以被不同的接口多次触发。</li></ul><h4 id="最终一致性与弱关联"><a href="#最终一致性与弱关联" class="headerlink" title="最终一致性与弱关联"></a>最终一致性与弱关联</h4><p>通常需要保证数据的最终一致性，这对于事件消息来说还是很容易的，这得益于基于消息的重试机制。与主业务关系不大的业务，如：发邮件，发短信等,这种弱关联是可以在事件中获益！</p><h2 id="如何实践事件总线"><a href="#如何实践事件总线" class="headerlink" title="如何实践事件总线"></a>如何实践事件总线</h2><blockquote><p>在 today 中台服务团队的各领域实践中，已经开始投产 eventbus ，并且效果可观，三方系统的订阅对接相当便捷.那这样的事件机制该如何去使用？</p></blockquote><p>为了给第三方系统和本部门的业务开发人员提供一致性的开发体验，我们将事件总线从dapeng的框架中剥离出来, 单独提供了一套类库用于实现事件的发布以及订阅。</p><h3 id="事件总线eventBus的核心库"><a href="#事件总线eventBus的核心库" class="headerlink" title="事件总线eventBus的核心库"></a>事件总线eventBus的核心库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;com.today&quot; % &quot;event-bus_2.12&quot; % &quot;0.1-SNAPSHOT&quot;</span><br></pre></td></tr></table></figure><h3 id="事件内容及状态暂存支持"><a href="#事件内容及状态暂存支持" class="headerlink" title="事件内容及状态暂存支持"></a>事件内容及状态暂存支持</h3><ul><li>需要在业务数据库加入一张如下结构数据表,这将作为事件消息的暂存队列和事件发送状态存储表<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`common_event`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>  <span class="keyword">COMMENT</span> <span class="string">'事件id'</span>,</span><br><span class="line">  <span class="string">`event_type`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'事件类型'</span>,</span><br><span class="line">  <span class="string">`event_binary`</span> <span class="built_in">blob</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'事件内容'</span>,</span><br><span class="line">  <span class="string">`updated_at`</span> <span class="keyword">timestamp</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">current_timestamp</span>() <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">current_timestamp</span>() <span class="keyword">COMMENT</span> <span class="string">'更新时间'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>这里以商品变价审核的状态变更为例，了解在开发中如何做事件发送与订阅.<br>具体来说,就是三步:</p><ol><li>定义事件结构体</li><li>在服务接口方法中声明待发布的事件</li><li>通过EventBus发布事件</li><li>通过EventBus接受事件</li></ol></blockquote><p>下面具体说明一下每个步骤</p><h2 id="作为事件消息发送者"><a href="#作为事件消息发送者" class="headerlink" title="作为事件消息发送者"></a>作为事件消息发送者</h2><h3 id="消息的定义和声明"><a href="#消息的定义和声明" class="headerlink" title="消息的定义和声明"></a>消息的定义和声明</h3><p>1.事件收发双方共同协定定义事件消息的内容, 一个领域的所有消息定义都在同一个独立的idl文件中. 这个idl文件应该放在发布者的API包中.</p><p>2.我们的事件对象需要定义一个事件 id (建议通过分布式取号服务来获取), 订阅者可以自己决定是否需要用这个事件 id 来做消息的幂等处理</p><p><code>==&gt; goods_events.thrift</code></p><figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> java com.today.api.goods.events</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 商品变价审核通过事件</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SkuPriceUpdateApprovedEvent</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 事件id</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="number">1</span>:<span class="built_in">i64</span> id,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * sku_id</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="number">2</span>:<span class="built_in">i64</span> skuId</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...more</span><br></pre></td></tr></table></figure><h3 id="声明事件"><a href="#声明事件" class="headerlink" title="声明事件"></a>声明事件</h3><blockquote><p>秉承代码及文档一致的理念，所有的服务都会在统一的文档站点进行开放展示，每个服务/每个接口的描述,包括出入参都一目了然.</p><ul><li>我们在服务接口方法里面声明需要发布的事件，这些事件清单将会在文档站点对应的服务方法中得到展示，减少服务开发人员的沟通成本，一看便知。</li></ul></blockquote><p><code>== &gt;goods_service.thrift</code></p><figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> java com.today.api.goods.<span class="keyword">service</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 用户服务</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">GoodsAdminService</span></span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"># 商品审核</span></span><br><span class="line"><span class="comment">## 事件</span></span><br><span class="line"><span class="comment">    1.SkuPriceUpdateApprovedEvent  商品变价审核通过事件</span></span><br><span class="line"><span class="comment">    2.SkuAttributeUpdateApprovedEvent  商品属性审核通过事件</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">    <span class="built_in">i64</span> approveSku(<span class="comment">/** 审核请求实体**/</span><span class="number">1</span>:goods_request.ApproveSkuRequest request)</span><br><span class="line">    (events=<span class="string">"com.today.api.goods.events.SkuPriceUpdateApprovedEvent,com.today.api.goods.events.SkuAttributeUpdateApprovedEvent"</span>)</span><br><span class="line">    ...more</span><br><span class="line">&#125;(group=<span class="string">"goods"</span>)</span><br></pre></td></tr></table></figure><ul><li>在文档站点方法上效果如下：<br><img src="http://oqr3htxnb.bkt.clouddn.com/18-3-11/65554100.jpg" alt=""></li><li>显示独立的事件清单<br><img src="http://oqr3htxnb.bkt.clouddn.com/18-3-11/90371526.jpg" alt=""></li></ul><blockquote><p>注：如果想要了解更多有关文档站点的内容，请留意后期的 dapeng 文档站点专题</p></blockquote><h3 id="定义事件发布任务"><a href="#定义事件发布任务" class="headerlink" title="定义事件发布任务"></a>定义事件发布任务</h3><p><code>==&gt; goods_event_task.thrift</code></p><figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> java com.today.api.goods.<span class="keyword">service</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 商品事件发布任务</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">GoodsScheduledService</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"># 事件发布</span></span><br><span class="line"><span class="comment">## 注意事项</span></span><br><span class="line"><span class="comment">    1.商品服务的事件发布任务</span></span><br><span class="line"><span class="comment">    2.不需在文档站点测试</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">    <span class="keyword">void</span> publishEventMsg()</span><br><span class="line">&#125;(group=<span class="string">"Scheduler"</span>)</span><br></pre></td></tr></table></figure><p>为发布任务服务提供以下实现模版</p><p><code>==&gt; task/GoodsScheduledServiceImpl.scala</code><br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ScheduledTask</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GoodsScheduledServiceImpl</span> <span class="keyword">extends</span> <span class="title">GoodsScheduledService</span></span>&#123;</span><br><span class="line">  <span class="meta">@Resource</span>(name = <span class="string">"messageTask"</span>)</span><br><span class="line">  <span class="keyword">var</span> msgScheduler: <span class="type">MsgPublishTask</span> = _</span><br><span class="line"></span><br><span class="line">  <span class="meta">@ScheduledTaskCron</span>(cron = <span class="string">"*/2 * * * * ?"</span>)</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">publishEventMsg</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">//EventBus已经处理了多节点同时触发的问题了</span></span><br><span class="line">    msgScheduler.doPublishMessages()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="关键性的bean配置"><a href="#关键性的bean配置" class="headerlink" title="关键性的bean配置"></a>关键性的bean配置</h3><ul><li><p>所有的事件消息，最终都会发送到 kafka 的队列中，等待订阅者消费；所以每一个配置都将必不可少。<br><code>==&gt; spring/services.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--messageTask 事件发布任务bean--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"messageTask"</span> <span class="attr">class</span>=<span class="string">"com.today.eventbus.scheduler.MsgPublishTask"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"topic"</span> <span class="attr">value</span>=<span class="string">"$&#123;KAFKA_TOPIC&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"kafkaHost"</span> <span class="attr">value</span>=<span class="string">"$&#123;KAFKA_PRODUCER_HOST&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"tidPrefix"</span> <span class="attr">value</span>=<span class="string">"$&#123;KAFKA_TID_PREFIX&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"tx_goods_dataSource"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>topic</code> kafka 消息 topic，领域区分(建议:领域_版本号_event)</p></li><li><code>kafkaHost</code> kafka 集群地址(如:127.0.0.1:9091,127.0.0.1:9092)</li><li><code>tidPrefix</code> kafka 事务 id 前缀，领域区分</li><li><code>dataSource</code> 使用业务的 dataSource</li></ul><p><code>==&gt; config_user_service.properties</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># event config</span><br><span class="line">KAFKA_TOPIC=goods_1.0.0_event</span><br><span class="line">KAFKA_PRODUCER_HOST=127.0.0.1:9092</span><br><span class="line">KAFKA_TID_PREFIX=goods_0.0.1</span><br></pre></td></tr></table></figure><p></p><h3 id="事件的触发"><a href="#事件的触发" class="headerlink" title="事件的触发"></a>事件的触发</h3><ul><li>在做事件触发前,你需要实现 <code>AbstractEventBus</code> ,并将其交由 spring 托管，来做好自定义的本地监听分发</li></ul><p><code>==&gt; commons/EventBus.scala</code><br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">EventBus</span> <span class="keyword">extends</span> <span class="title">AbstractEventBus</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 事件在触发后，可能存在领域内的订阅者，以及跨领域的订阅者</span></span><br><span class="line"><span class="comment">    * 领域内的订阅者可以通过实现该方法进行分发</span></span><br><span class="line"><span class="comment">    * 同时,也会将事件发送到其他领域的事件消息订阅者</span></span><br><span class="line"><span class="comment">    * @param event</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">dispatchEvent</span></span>(event: <span class="type">Any</span>): <span class="type">Unit</span> = &#123;&#125;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">getInstance</span></span>: <span class="type">EventBus</span>.<span class="keyword">this</span>.<span class="keyword">type</span> = <span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>==&gt; spring/services.xml</code><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"eventBus"</span> <span class="attr">class</span>=<span class="string">"com.today.service.commons.EventBus"</span> <span class="attr">factory-method</span>=<span class="string">"getInstance"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"tx_goods_dataSource"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p><ul><li>事件发布</li><li>之前的配置都是一劳永逸的。之后的所有事件发布都会和下面的一行代码一样简单！<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">EventBus</span>.fireEvent(<span class="type">RegisteredEvent</span>(event_id,user.id))</span><br></pre></td></tr></table></figure></li></ul><h2 id="订阅你感兴趣的事件"><a href="#订阅你感兴趣的事件" class="headerlink" title="订阅你感兴趣的事件"></a>订阅你感兴趣的事件</h2><h3 id="对于领域内订阅者"><a href="#对于领域内订阅者" class="headerlink" title="对于领域内订阅者"></a>对于领域内订阅者</h3><p><code>EventBus</code> 的 <code>dispatchEvent</code> 方法提供领域内订阅者的事件分发，以便本地订阅者可以订阅到关注的事件消息。这些领域内的订阅者，只需要在 <code>dispatchEvent</code> 中模式匹配进行分发。是不是已经是相当的简洁呢？</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"> <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">dispatchEvent</span></span>(event: <span class="type">Any</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">     event <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> e:<span class="type">SkuPriceUpdateApprovedEvent</span> =&gt;</span><br><span class="line">        <span class="comment">// do somthing </span></span><br><span class="line">      <span class="keyword">case</span> _ =&gt;</span><br><span class="line">        <span class="type">LOGGER</span>.info(<span class="string">" nothing "</span>)</span><br><span class="line"> &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="对于跨领域的订阅者"><a href="#对于跨领域的订阅者" class="headerlink" title="对于跨领域的订阅者"></a>对于跨领域的订阅者</h3><h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h4><ul><li>针对其他领域服务及第三方系统，提供了一致的 api。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--if =&gt; maven project--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.today<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>event-bus_2.12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--if =&gt; sbt project--&gt;</span> </span><br><span class="line">"com.today" % "event-bus_2.12" % "0.1-SNAPSHOT"</span><br></pre></td></tr></table></figure><ul><li><p>注解扫描支持配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"postProcessor"</span> <span class="attr">class</span>=<span class="string">"com.today.eventbus.MsgAnnotationBeanPostProcessor"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>订阅事件消息<br>同一个领域的事件在同一个消费者类中处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java</span></span><br><span class="line"><span class="meta">@KafkaConsumer</span>(groupId = <span class="string">"goodsEventConsumer"</span>, topic = <span class="string">"goods_1.0.0_event"</span>,kafkaHostKey = <span class="string">"kafka.consumer.host"</span>))</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GoodsEventsConsumer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@KafkaListener</span>(serializer = SkuAttributeUpdateApprovedEventSerializer.class)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribeSkuAttributeUpdateApprovedEvent</span><span class="params">(SkuAttributeUpdateApprovedEvent event)</span> </span>&#123;</span><br><span class="line">        System.out.println(event.skuId);</span><br><span class="line">        <span class="comment">// do somthing</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//scala</span></span><br><span class="line">serializer = classOf[RegisteredEventSerializer]</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li><p><code>GoodsEventsConsumer</code> 也需要在 spring 上下文中托管。</p></li></ul><blockquote><p>@KafkaConsumer</p></blockquote><ul><li>groupId   kafka 消费者 groupId ，订阅者领域区分</li><li>topic     订阅的 kafka 消息 topic </li><li>kafkaHostKey  可自行配置的 kafka 地址，默认值为<code>dapeng.kafka.consumer.host</code>。可以自定义以覆盖默认值<ul><li>用户只要负责把这些配置放到 env 或者 properties 里面</li><li>如：<code>System.setProperty(&quot;kafka.consumer.host&quot;,&quot;127.0.0.1:9092&quot;);</code></li></ul></li></ul><blockquote><p>@KafkaListener</p></blockquote><ul><li>serializer 事件消息解码器，由事件发送方提供.</li></ul><h2 id="领域内消费事件与跨领域消费事件的异同"><a href="#领域内消费事件与跨领域消费事件的异同" class="headerlink" title="领域内消费事件与跨领域消费事件的异同"></a>领域内消费事件与跨领域消费事件的异同</h2><p>通过以上已经知道在事件中，存在领域内的订阅者消费事件消息，也可能存在跨领域的事件订阅者消费事件消息。这两者有何异同？</p><ul><li>领域内的事件订阅者，通常是不能脱离领域的存在，存在领域内强关系的。但又需要解藕！可以用领域内消费事件。eventbus 领域内的消息分发订阅，就可以保证这种强关系一致存在</li><li>在 eventbus 中，领域内消费事件之后还是会将事件消息广播出去。因为不能保证不存在其他领域的事件订阅者！</li><li>而跨领域的事件消息订阅，通常是需要保证最终一致性即可，或者是弱关联其他领域的，他们对于事件发送发送方没有强依赖关系，只需要得到自己需要的东西就可以。</li></ul><blockquote><p>比如商品领域的商品变价审核通过后，广播了一个事件。将商品id发送给关注此事的领域，这与领域内部是没有关联的，甚至于发送者并不知道事件消息订阅者如何处理。而订阅者也只想得到这部分信息而已！</p></blockquote><h2 id="订阅业务数据库binlog消息"><a href="#订阅业务数据库binlog消息" class="headerlink" title="订阅业务数据库binlog消息"></a>订阅业务数据库binlog消息</h2><p>将订阅者 api 进行了有趣的拓展，和事件消息类似的。加入新的点子来做 binlog 的订阅处理。</p><pre><code class="java"><span class="meta">@BinlogListener</span>  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">binlogListener</span><span class="params">(List&lt;BinlogEvent&gt; events)</span></span>{      <span class="comment">// do somthing</span>  }</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总体来说，不论是事件的发送还是订阅，对于开发者而言都是易用的。并且没有多余的配置。对于第三方系统的支持也做的非常优秀，希望在日常开发中能够更加灵活的运用。尽量减少不必要的耦合！并能经受实践考验！</p><ul><li>原文地址: <a href="http://git66.com/2018/03/10/DDD-event-bus/">http://git66.com/2018/03/10/DDD-event-bus/</a></li><li>同步简书地址: <a href="https://www.jianshu.com/p/88abce9326aa" target="_blank" rel="noopener">https://www.jianshu.com/p/88abce9326aa</a></li></ul><blockquote><p>有关eventBus的具体实现细节，将由小伙伴 hz.lei 来进行剖析！</p></blockquote><ul><li>hz.lei: <a href="https://www.jianshu.com/p/f89741097113" target="_blank" rel="noopener">DDD-事件总线实现架构原理分析</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/dapeng-soa&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;@大鹏开源&lt;/a&gt;:别看我有点萌，我可以秒变大鹏😄&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://oqr3htxnb.bkt.clouddn.com/18-3-10/59987509.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;DDD-与领域事件&quot;&gt;&lt;a href=&quot;#DDD-与领域事件&quot; class=&quot;headerlink&quot; title=&quot;DDD 与领域事件&quot;&gt;&lt;/a&gt;DDD 与领域事件&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在过去的 30 多年，就已经有领域建模和设计的思潮；Eric Evans 将其定义为领域驱动设计（Domain-Driven Design，简称DDD）。领域模型是领域驱动的核心，而领域事件又作为领域模型中的重要模块，解决了开发者日常开发中的很多痛点，比如，代码藕合降低，拓展性增强。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;领域模型不是高大上的东西，所有的领域模型抽象都来自于具体的业务及业务的需求,而脱离业务需求的应用设计是没有任何价值的！&lt;/p&gt;
&lt;p&gt;比如在Today的新零售电商架构中:门店、采购、订单、供应商、物流、商品、台账等等都是应用设计中的不同领域模型，必然还存在或多或少的子域模型。而对于技术人员来说，这些抽象出来的领域，就代表应用架构存在若干子系统。&lt;/p&gt;
&lt;p&gt;系统与系统间，势必会存在某些关联。比如说A领域“发生某件事情”、“当什么产生变化的时候”、“如果什么状态变更”…，都将可能成为B领域所要关心的事件。&lt;/p&gt;
    
    </summary>
    
    
      <category term="DDD" scheme="http://git66.com/tags/DDD/"/>
    
      <category term="领域驱动设计" scheme="http://git66.com/tags/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="领域事件" scheme="http://git66.com/tags/%E9%A2%86%E5%9F%9F%E4%BA%8B%E4%BB%B6/"/>
    
      <category term="eventbus" scheme="http://git66.com/tags/eventbus/"/>
    
      <category term="dapeng" scheme="http://git66.com/tags/dapeng/"/>
    
  </entry>
  
  <entry>
    <title>【scala】函数的演变过程,函数式的优点</title>
    <link href="http://git66.com/2018/01/06/scala-function-5w/"/>
    <id>http://git66.com/2018/01/06/scala-function-5w/</id>
    <published>2018-01-06T14:05:50.000Z</published>
    <updated>2018-03-06T15:15:56.499Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>scala中，带有函数式编程思想的代码很多，如何去理解才更加容易？</p></blockquote><p><img src="http://oqr3htxnb.bkt.clouddn.com/18-1-6/5222114.jpg" alt=""></p><a id="more"></a><ul><li><p>传统</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def plusOne(num:Int):Int = &#123;</span><br><span class="line">    num+1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>改革过程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(Int)=&gt;Int // 函数的&quot;类型&quot;提取</span><br><span class="line"></span><br><span class="line">(num)=&gt;&#123;</span><br><span class="line">    num+1 // 函数的&quot;值&quot;提取</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(num)=&gt;num+1</span><br></pre></td></tr></table></figure></li><li><p>结合改革成果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val plusOne:Int=&gt;Int=&#123;</span><br><span class="line">    (num)=&gt;num+1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>还可以变</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val plusOne=(num:Int) =&gt; num+1</span><br></pre></td></tr></table></figure></li><li><p>函数的字面量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(num:Int) =&gt; num+1</span><br></pre></td></tr></table></figure></li></ul><h3 id="何处使用"><a href="#何处使用" class="headerlink" title="何处使用"></a>何处使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">val nums=List[Int](1,2,3)</span><br><span class="line">@#</span><br><span class="line">map(f:Int =&gt; B)</span><br><span class="line">// 这是scala中map方法的定义</span><br><span class="line">// 这里指出map方法需要接受一个Int类型的值f，任意的表达式运算B</span><br><span class="line">// 回过头再把函数的的变革过程想一遍那它应该是怎样&quot;一类的函数&quot;</span><br><span class="line"></span><br><span class="line">//下面是我的理解</span><br><span class="line">(x:Int) =&gt; B // 此时B看作最后的运算结果得到的类型</span><br><span class="line"></span><br><span class="line">(x)=&gt;&#123;</span><br><span class="line">    B // 此时B看作是一个过程</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val plusOne=(x:Int) =&gt; x+1</span><br><span class="line">val mString=(x:Int) =&gt; x.toString</span><br><span class="line"></span><br><span class="line">@A</span><br><span class="line">nums.map((x:Int) =&gt; x+1)</span><br><span class="line"></span><br><span class="line">@B</span><br><span class="line">nums.map(plusOne)</span><br><span class="line"></span><br><span class="line">@C</span><br><span class="line">nums.map(mString)</span><br></pre></td></tr></table></figure><ul><li>@A和@B达到了同样的效果</li><li>plusOne和mString是一类函数，可插拔(引用透明)</li><li>plusOne和mString都是从值=&gt;值的过程，是一条线(纯函数)，这就涉及到函数的副作用</li></ul><h3 id="函数副作用-摘自维基"><a href="#函数副作用-摘自维基" class="headerlink" title="函数副作用(摘自维基)"></a>函数副作用(摘自维基)</h3><blockquote><p>函数副作用指当调用函数时，除了返回函数值之外，还对主调用函数产生附加的影响。例如修改全局变量（函数外的变量）或修改参数。</p></blockquote><ul><li>纯函数<ul><li>输入输出数据流全是显式（Explicit）的 </li><li>函数与外界交换数据只有一个唯一渠道——参数和返回值</li><li>没有副作用的函数</li></ul></li><li>非纯函数<ul><li>函数通过隐式（Implicit）方式，从外界获取数据，或者向外部输出数据</li><li>比如，读取全局变量，修改全局变量</li></ul></li><li>引用透明<ul><li>引用透明（Referential Transparent）的概念与函数的副作用相关，且受其影响</li><li>如果程序中任意两处具有<strong>相同输入值的函数</strong>调用能够互相置换，而不影响程序的动作，那么该程序就具有引用透明性</li></ul></li></ul><h3 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h3><ul><li><p>纯函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f(x) &#123; </span><br><span class="line">   return x + 1 </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>非纯函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = 0 </span><br><span class="line">q(x) &#123; </span><br><span class="line">   b = a </span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">p(x)&#123; </span><br><span class="line">    print“hello” </span><br><span class="line">&#125;</span><br><span class="line">// p(x)通过I/O API输出了一个字符串。p(x)是非纯函数。</span><br></pre></td></tr></table></figure></li></ul><h3 id="纯函数优点"><a href="#纯函数优点" class="headerlink" title="纯函数优点"></a>纯函数优点</h3><ul><li>无状态。线程安全。不需要线程同步。</li><li>纯函数相互调用组装起来的函数，还是纯函数。</li><li>应用程序或者运行环境（Runtime）可以对纯函数的运算结果进行缓存，运算加快速度。</li></ul><p>参考</p><p><a href="http://blog.csdn.net/bluishglc/article/details/45291533" target="_blank" rel="noopener">http://blog.csdn.net/bluishglc/article/details/45291533</a></p><p><a href="https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0%E5%89%AF%E4%BD%9C%E7%94%A8" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0%E5%89%AF%E4%BD%9C%E7%94%A8</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;scala中，带有函数式编程思想的代码很多，如何去理解才更加容易？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://oqr3htxnb.bkt.clouddn.com/18-1-6/5222114.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="scala" scheme="http://git66.com/tags/scala/"/>
    
      <category term="函数式编程" scheme="http://git66.com/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Angular(4)中加载Arcgis for JavaScript地图</title>
    <link href="http://git66.com/2017/09/16/Angular-load-ArcGis-for-JavaScript/"/>
    <id>http://git66.com/2017/09/16/Angular-load-ArcGis-for-JavaScript/</id>
    <published>2017-09-16T06:40:36.000Z</published>
    <updated>2018-03-08T13:47:14.816Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><blockquote><p>近期我司项目的需要，采用Angular(4)+SpringBoot前后端分离的架构。并且在需要在项目中实现Arcgis地图。  </p></blockquote><h2 id="寻"><a href="#寻" class="headerlink" title="寻"></a>寻</h2><p>像我这种菜鸡遇到这种没有干过的事情肯定是先问百度和谷歌,两个关键词敲下。几乎搜索的内容里很少有两个关键字共存的。但是我这慧眼识得好代码，于是发现了这: <a href="https://github.com/Esri/angular-esri-map" target="_blank" rel="noopener">https://github.com/Esri/angular-esri-map</a></p><p>Esri是美国环境系统研究所公司,多年来，ESRI公司始终将GIS视为一门科学.也就是说这是官方实例呀。</p><a id="more"></a><p>这样就完了吗？不，事情总是没那么简单的。我以负八级的英文水平开始看这个项目的README,第一行。心都碎了[手动心碎]他是这样说的。</p><blockquote><p>A collection of directives to help you use Esri maps and services in your AngularJS v1.x applications.</p></blockquote><p>wtf?==&gt;AngularJS v1.x applications，我的项目用的可是4.x，这不扯淡？</p><p>继续遨游在GayHub[手动滑稽]的代码海洋里。皇天不负有心人让我找到了他:<br><a href="https://github.com/tomwayson/angular2-esri-example" target="_blank" rel="noopener">https://github.com/tomwayson/angular2-esri-example</a></p><p>在这里我尝试将他的项目clone到本地，的确可以跑起来，并且可以看到地图,但尝试获取核心代码但是在包下载的时候就出现了很多问题于是放弃了[真的是无限差包]。</p><h2 id="雾"><a href="#雾" class="headerlink" title="雾"></a>雾</h2><p>因为之前看到是2.x版本就机遇尝试便没有仔细阅读本项目的说明文档。回去看他的说明文档并把<code>Resources</code>节点下的东西都挨个看了一遍,发现了其中一项貌似很有用：</p><ul><li><a href="https://github.com/tomwayson/esri-angular-cli-example" target="_blank" rel="noopener">Example of how to use the ArcGIS API for JavaScript in an angular-cli application</a></li><li>【译】如何在 Angular CLI 程序中使用ArcGIS API for JavaScript的示例</li></ul><p>于是开始阅读这个示例的说明文档，他在文中提到:</p><blockquote><p>This repository is an example of one way to use the ArcGIS API for JavaScript in an application generated with angular-cli.<br>此存储库是在使用angular-cli生成的应用程序中使用ArcGIS API for JavaScript的一种方法的示例</p></blockquote><p>还有一句:</p><blockquote><p>Adding the ArcGIS API to your own angular-cli application<br>将ArcGIS API添加到您自己的Angular-cli应用程序</p><p>Rather than clone this repository, you should create your own application with the angular-cli and then follow the instructions below to add the above libraries:<br>而不是克隆此存储库，您应该使用angular-cli创建自己的应用程序，然后按照以下说明添加以上库：</p></blockquote><p>下面的是说明：</p><ul><li><a href="https://github.com/tomwayson/angular-esri-loader/blob/master/README.md#in-an-angular-cli-application" target="_blank" rel="noopener">angular2-esri-loader</a> - a low level service needed to load and use ArcGIS modules (v3.x or v4.x) in your Angular applications<ul><li>在Angular应用程序中加载和使用ArcGIS模块（v3.x或v4.x）所需的低级服务</li></ul></li><li><a href="https://github.com/TheKeithStewart/angular-esri-components#setup" target="_blank" rel="noopener">angular-esri-components</a> - a set of reusable components for use with v4.x (only) of the ArcGIS API<ul><li>一组（仅）可用于ArcGIS API v4.x的可重用组件</li></ul></li></ul><hr><p>上面的意思已经很清楚。这个项目不建议clone，而是使用angular2-esri-loader 来加载ArcGIS模块，angular-esri-components组件是只能在Arcgis4.x版本中使用的。</p><p>当点开<a href="https://github.com/tomwayson/angular-esri-loader/blob/master/README.md#in-an-angular-cli-application" target="_blank" rel="noopener">angular2-esri-loader</a>这个模块的时候，会很清楚的看到如何安装这个Angular的gis加载库，并且写了示例程序。对于angular有一定的了解的话，这些代码或许就能很清晰的表达出它在做什么。</p><p>示例的代码就不列出，可以到github上阅读。大体流程是：</p><ul><li>npm安装<a href="https://github.com/tomwayson/angular-esri-loader" target="_blank" rel="noopener">angular-esri-loader</a>,Angular版本不同则安装的命令和库也会存在差异</li><li>EsriLoaderModule模块加载到程序中</li><li>使用EsriLoaderService组件加载地图</li><li>文档中加载的是基础图层，但一般开发时会加载缓存地图服务或者其他类型地图服务。这将在我的的示例项目中看到</li></ul><p>项目示例:<br><a href="https://git.oschina.net/StruggleYang/ngGisDemo" target="_blank" rel="noopener">https://git.oschina.net/StruggleYang/ngGisDemo</a></p><p>项目效果:  </p><p><img src="http://oqr3htxnb.bkt.clouddn.com/17-9-16/48529141.jpg" alt=""></p><h2 id="差"><a href="#差" class="headerlink" title="差"></a>差</h2><p>你如果看过Arcgis for JavaScript的代码。那么JavaScript代码，如何转换为Angular(TypeScript)的代码，这里我也没有做过多的了解，只是照葫芦画瓢写的一些:  </p><p>这里推荐去看一下阮一峰的:<a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener">ES6标准入门</a>可以提供一些参考  </p><p>下面将做出原生的Arcgis for JavaScript代码和Angular中的书写对比。</p><p>变量声明：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有可能你需要在地图初始化前首先声明变量，以便你在任何地方都是可用的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> map; <span class="comment">// js</span></span><br><span class="line"></span><br><span class="line">map: any; <span class="comment">// ts</span></span><br></pre></td></tr></table></figure><p>地图的模块加载，Arcgis的api是基于dojo框架的，如下:</p><ul><li>JavaScript中加载地图模块</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> map;</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>([<span class="string">"esri/map"</span>, <span class="string">"dojo/domReady!"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">Map</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(<span class="string">"map"</span>, &#123;</span><br><span class="line">    center: [<span class="number">-118</span>, <span class="number">34.5</span>],</span><br><span class="line">    zoom: <span class="number">8</span>,</span><br><span class="line">    basemap: <span class="string">"topo"</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>Angular中加载地图(基于angular-esri-loader加载器)<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里代码并不全，具体请查看上面的示例项目</span></span><br><span class="line">.. 省略导入</span><br><span class="line"></span><br><span class="line"><span class="meta">@ViewChild</span>(<span class="string">'map'</span>) mapEl: ElementRef;</span><br><span class="line"> map: <span class="built_in">any</span>;</span><br><span class="line"></span><br><span class="line"> ngOnInit() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.esriLoader.load(&#123;</span><br><span class="line">    <span class="comment">// 在js中是不管这个url的，因为它在html中已经引入对应的版本</span></span><br><span class="line">      url: <span class="string">'//js.arcgis.com/3.18/'</span></span><br><span class="line">    &#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.esriLoader.loadModules([<span class="string">'esri/map'</span>]).then(<span class="function">(<span class="params">[Map]</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.map = <span class="keyword">new</span> Map(<span class="keyword">this</span>.mapEl.nativeElement, &#123;</span><br><span class="line">          center: [<span class="number">-118</span>, <span class="number">34.5</span>],</span><br><span class="line">          zoom: <span class="number">8</span>,</span><br><span class="line">          basemap: <span class="string">'topo'</span></span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>dojo事件添加:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">// dojo点击事件添加 by JavaScript</span></span><br><span class="line">dojo.connect(map, <span class="string">'onClick'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> emp = evt.mapPoint;</span><br><span class="line">    <span class="keyword">var</span> cur_wkid = emp.spatialReference.wkid; </span><br><span class="line">    ... more code</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment">// dojo点击事件添加 by Angular</span></span><br><span class="line">dojo.connect(<span class="keyword">this</span>.map, <span class="string">'onClick'</span>, (evt) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> emp = evt.mapPoint;</span><br><span class="line">    <span class="keyword">const</span> cur_wkid = emp.spatialReference.wkid; </span><br><span class="line">    ... more code</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这里实际上就是一个箭头函数的区别还有变量的声明区别。</p><h2 id="花"><a href="#花" class="headerlink" title="花"></a>花</h2><p>这就结束了？</p><p>不不不，远远还不只这些。不论是Angular还是Arcgis,很多东西都没有做过多的了解和深入。不知道那行代码存在隐患。所以革命尚未成功，还得加倍学习和实践巩固。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;近期我司项目的需要，采用Angular(4)+SpringBoot前后端分离的架构。并且在需要在项目中实现Arcgis地图。  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;寻&quot;&gt;&lt;a href=&quot;#寻&quot; class=&quot;headerlink&quot; title=&quot;寻&quot;&gt;&lt;/a&gt;寻&lt;/h2&gt;&lt;p&gt;像我这种菜鸡遇到这种没有干过的事情肯定是先问百度和谷歌,两个关键词敲下。几乎搜索的内容里很少有两个关键字共存的。但是我这慧眼识得好代码，于是发现了这: &lt;a href=&quot;https://github.com/Esri/angular-esri-map&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/Esri/angular-esri-map&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Esri是美国环境系统研究所公司,多年来，ESRI公司始终将GIS视为一门科学.也就是说这是官方实例呀。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Angular" scheme="http://git66.com/tags/Angular/"/>
    
      <category term="WebGis" scheme="http://git66.com/tags/WebGis/"/>
    
      <category term="Arcgis for JavaScript" scheme="http://git66.com/tags/Arcgis-for-JavaScript/"/>
    
      <category term="地图" scheme="http://git66.com/tags/%E5%9C%B0%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>一个命令,解决hexo多机更新操作</title>
    <link href="http://git66.com/2017/09/09/hexo-all-update-by-shell/"/>
    <id>http://git66.com/2017/09/09/hexo-all-update-by-shell/</id>
    <published>2017-09-08T23:44:46.000Z</published>
    <updated>2018-03-06T15:45:50.794Z</updated>
    
    <content type="html"><![CDATA[<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>因为本博客是基于Hexo+GitHub-Pages,所以在<code>hexo -d</code>后生成的静态文件都存放于github，所以这是不用担心的。本地的hexo博客的源文件内存放着大量的文章markdown文件,所以问题来了。如果换电脑或者硬件损坏，或者有在其他机器更新文章的需求。就需要做一件事情就是将源文件，也就是本地hexo博客源文件的根目录整个备份。</p><a id="more"></a><p>在那么现在就必须做一些前置操作，就是把你的hexo博客源文件备份到GitHub或者其他代码托管平台，这里的操作就不写出来了，可以参考<a href="http://www.struy.top/2017/09/02/git%E5%88%9D%E8%AF%86/" target="_blank" rel="noopener">罪恶的起源，git初识</a>里的如何将代码提交到远程仓库。</p><blockquote><p>也可以使用开源中国的<a href="https://git.oschina.net/" target="_blank" rel="noopener">码云</a>,我就是用的码云[手动滑稽]，操作都是一样的。</p><p>清除hexo的<code>public</code>目录=&gt;重新生成静态文件=&gt;更新github pages的文章内容=&gt;拉取其他机器的提交=&gt;将所有的文章Markdown源文件改动add到本地暂存=&gt;提交=&gt;push源文件到另一个备份仓库</p></blockquote><p>那么这个命令如何实现，在上一篇文章的额基础上，我对三个命令做出了拓展，使它有一些基本的功能，比如<code>help</code>,防止自己也忘了这个命令干嘛的。加入了只是本地预览博客的指令<code>-s</code>。已经一些友好的提示,让你知道它都做了什么。那么来看看这个命令的脚本长什么样吧！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  by StruggleYang</span></span><br><span class="line"><span class="comment">#  this is update hexo page or post and backup source</span></span><br><span class="line">this=<span class="variable">$0</span></span><br><span class="line">message=<span class="variable">$1</span></span><br><span class="line"><span class="built_in">help</span>=<span class="string">"help"</span></span><br><span class="line">server=<span class="string">"-s"</span></span><br><span class="line"><span class="comment"># Always pull the latest</span></span><br><span class="line">git pull origin master &amp;&amp;</span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$message</span>"</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$message</span>"</span> = <span class="string">"<span class="variable">$help</span>"</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$this</span>&gt;&gt;help : "</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"There is only one parameter: commit-message  or -s [locahost server preview Blog] "</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"After the command, add updates to this blog and submit it to the backup repository!"</span></span><br><span class="line"><span class="keyword">elif</span> [ <span class="string">"<span class="variable">$message</span>"</span> = <span class="string">"<span class="variable">$server</span>"</span> ]  </span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$this</span> ====hexo &gt;&gt; clean &gt;&gt; generate &gt;&gt; server "</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"==========hexo clean  ...==========="</span> &amp;&amp;</span><br><span class="line">hexo clean &amp;&amp; </span><br><span class="line"><span class="built_in">echo</span> <span class="string">"==========hexo generate ...========="</span> &amp;&amp;</span><br><span class="line">hexo g &amp;&amp; </span><br><span class="line"><span class="built_in">echo</span> <span class="string">"==========hexo server ...========="</span> &amp;&amp;</span><br><span class="line">hexo s</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$this</span> ==== [hexo] &gt;&gt; clean &gt;&gt; generate &gt;&gt; deploy ==|~|== [git] &gt;&gt; add &gt;&gt; commit &gt;&gt; push "</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"==========hexo clean  ...==========="</span> &amp;&amp;</span><br><span class="line">hexo clean &amp;&amp; </span><br><span class="line"><span class="built_in">echo</span> <span class="string">"==========hexo generate ...========="</span> &amp;&amp;</span><br><span class="line">hexo g &amp;&amp; </span><br><span class="line"><span class="built_in">echo</span> <span class="string">"==========hexo deploy ...==========="</span> &amp;&amp;</span><br><span class="line">hexo d &amp;&amp; </span><br><span class="line"><span class="built_in">echo</span> <span class="string">"==========backup hexo source to git.osc ...========="</span> &amp;&amp;</span><br><span class="line">git add -A . &amp;&amp; </span><br><span class="line"><span class="built_in">echo</span> <span class="string">"==========commit message: [ <span class="variable">$message</span> ]========="</span> &amp;&amp;</span><br><span class="line">git commit -m <span class="string">"<span class="variable">$message</span>"</span> &amp;&amp; git push origin master</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$this</span>&gt;&gt;help : "</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"There is only one parameter: commit-message  or help or -s [locahost server preview Blog]"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"After the command, add updates to this blog and submit it to the backup repository!"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">" ==========Over==========="</span></span><br></pre></td></tr></table></figure><p>假设已经将此脚本命名为<code>up.sh</code>  </p><p>当我输入 <code>sh up.sh</code>时：<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sh up.sh</span><br><span class="line">        up.sh&gt;&gt;<span class="built_in">help</span> :</span><br><span class="line">        There is only one parameter: commit-message  or <span class="built_in">help</span> or -s [locahost server preview Blog]</span><br><span class="line">        After the command, add updates to this blog and submit it to the backup repository!</span><br><span class="line"> ==========Over===========</span><br></pre></td></tr></table></figure></p><p>当我输入<code>sh up.sh help</code>提示和以上一样，所以我是希望能够在每次更新和提交时，能够足够便捷，并且能够提示我填写commit的desc<br>还有一个指令是<code>-s</code> ，这个指令的作用显而易见只是将hexo的page重新生成并且能够本地预览。获取并不想提交更新，或者只是调试！</p><p>当我真正的需要更新文章或者博客的布局，并且备份元数据！<br>只需要这样写:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sh up.sh &quot;this is commit message test&quot;</span><br></pre></td></tr></table></figure></p><p>运行如下:<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">F:\<span class="title">hexo</span> (<span class="title">master</span>)                                                                                  </span></span><br><span class="line"><span class="function">λ <span class="title">sh</span> <span class="title">up.sh</span> "<span class="title">this</span> <span class="title">is</span> <span class="title">commit</span> <span class="title">message</span> <span class="title">test</span>"                                                                            </span></span><br><span class="line"><span class="function">        <span class="title">up.sh</span> ==== [<span class="title">hexo</span>] &gt;&gt; <span class="title">clean</span> &gt;&gt; <span class="title">generate</span> &gt;&gt; <span class="title">deploy</span> ==|~|== [<span class="title">git</span>] &gt;&gt; <span class="title">add</span> &gt;&gt; <span class="title">commit</span> &gt;&gt; <span class="title">push</span>                        </span></span><br><span class="line"><span class="function">==========<span class="title">hexo</span> <span class="title">clean</span>  ...===========                                                                                   </span></span><br><span class="line"><span class="function"><span class="title">INFO</span>  <span class="title">Deleted</span> <span class="title">database</span>.                                                                                                </span></span><br><span class="line"><span class="function"><span class="title">INFO</span>  <span class="title">Deleted</span> <span class="title">public</span> <span class="title">folder</span>.                                                                                           </span></span><br><span class="line"><span class="function">==========<span class="title">hexo</span> <span class="title">generate</span> ...=========                                                                                   </span></span><br><span class="line"><span class="function"><span class="title">INFO</span>  <span class="title">Start</span> <span class="title">processing</span>                                                                                                 </span></span><br><span class="line"><span class="function"><span class="title">INFO</span>  <span class="title">Files</span> <span class="title">loaded</span> <span class="title">in</span> 1.4 <span class="title">s</span>                                                                                            </span></span><br><span class="line"><span class="function"><span class="title">INFO</span>  <span class="title">Generated</span>: <span class="title">content.json</span>                                                                                          </span></span><br><span class="line"><span class="function"><span class="title">INFO</span>  <span class="title">Generated</span>: <span class="title">index.html</span>                                                                                            </span></span><br><span class="line"><span class="function"><span class="title">INFO</span>  <span class="title">Generated</span>: <span class="title">tools</span>/<span class="title">index.html</span>                                                                                      </span></span><br><span class="line"><span class="function"><span class="title">INFO</span>  <span class="title">Generated</span>: <span class="title">soul</span>/<span class="title">index.html</span> </span></span><br><span class="line"><span class="function">........省略部分                                                                                  </span></span><br><span class="line"><span class="function">==========<span class="title">hexo</span> <span class="title">deploy</span> ...===========                                                                                   </span></span><br><span class="line"><span class="function"><span class="title">INFO</span>  <span class="title">Deploying</span>: <span class="title">git</span>                                                                                                   </span></span><br><span class="line"><span class="function"><span class="title">INFO</span>  <span class="title">Clearing</span> .<span class="title">deploy_git</span> <span class="title">folder</span>...                                                                                   </span></span><br><span class="line"><span class="function"><span class="title">INFO</span>  <span class="title">Copying</span> <span class="title">files</span> <span class="title">from</span> <span class="title">public</span> <span class="title">folder</span>...                                                                              </span></span><br><span class="line"><span class="function"><span class="title">INFO</span>  <span class="title">Copying</span> <span class="title">files</span> <span class="title">from</span> <span class="title">extend</span> <span class="title">dirs</span>...     </span></span><br><span class="line"><span class="function">........省略部分                                                                             </span></span><br><span class="line"><span class="function"><span class="title">INFO</span>  <span class="title">Deploy</span> <span class="title">done</span>: <span class="title">git</span>                                                                                                 </span></span><br><span class="line"><span class="function">==========<span class="title">backup</span> <span class="title">hexo</span> <span class="title">source</span> <span class="title">to</span> <span class="title">git.osc</span> ...=========                                                                   </span></span><br><span class="line"><span class="function"><span class="title">warning</span>: <span class="title">LF</span> <span class="title">will</span> <span class="title">be</span> <span class="title">replaced</span> <span class="title">by</span> <span class="title">CRLF</span> <span class="title">in</span> <span class="title">source</span>/<span class="title">_posts</span>/<span class="title">hexo</span>-<span class="title">all</span>-<span class="title">update</span>-<span class="title">by</span>-<span class="title">shell.md</span>.                                     </span></span><br><span class="line"><span class="function"><span class="title">The</span> <span class="title">file</span> <span class="title">will</span> <span class="title">have</span> <span class="title">its</span> <span class="title">original</span> <span class="title">line</span> <span class="title">endings</span> <span class="title">in</span> <span class="title">your</span> <span class="title">working</span> <span class="title">directory</span>.                                                </span></span><br><span class="line"><span class="function">==========<span class="title">commit</span> <span class="title">message</span>: [ <span class="title">this</span> <span class="title">is</span> <span class="title">commit</span> <span class="title">message</span> <span class="title">test</span> ]=========                                                     </span></span><br><span class="line"><span class="function">3 <span class="title">files</span> <span class="title">changed</span>, 34 <span class="title">insertions</span>(+), 2 <span class="title">deletions</span>(-)</span></span><br><span class="line"><span class="function"><span class="title">Counting</span> <span class="title">objects</span>: 27, <span class="title">done</span>.</span></span><br><span class="line"><span class="function"><span class="title">Delta</span> <span class="title">compression</span> <span class="title">using</span> <span class="title">up</span> <span class="title">to</span> 4 <span class="title">threads</span>.</span></span><br><span class="line"><span class="function"><span class="title">Compressing</span> <span class="title">objects</span>: 100% (27/27), <span class="title">done</span>.</span></span><br><span class="line"><span class="function"><span class="title">Writing</span> <span class="title">objects</span>: 100% (27/27), 14.86 <span class="title">KiB</span> | 0 <span class="title">bytes</span>/<span class="title">s</span>, <span class="title">done</span>.</span></span><br><span class="line"><span class="function"><span class="title">Total</span> 27 (<span class="title">delta</span> 14), <span class="title">reused</span> 0 (<span class="title">delta</span> 0)</span></span><br><span class="line"><span class="function"><span class="title">To</span> <span class="title">https</span>://<span class="title">git.oschina.net</span>/<span class="title">StruggleYang</span>/<span class="title">hexo.git</span></span></span><br><span class="line"><span class="function">   <span class="title">d9838c0</span>..50<span class="title">bb11d</span>  <span class="title">master</span> -&gt; <span class="title">master</span>                          </span></span><br><span class="line"><span class="function"> ==========<span class="title">Over</span>===========</span></span><br></pre></td></tr></table></figure></p><h2 id="如何多机更新"><a href="#如何多机更新" class="headerlink" title="如何多机更新"></a>如何多机更新</h2><p>等你换了电脑或者公司的电脑来更新的的时候。前提是这台电脑是需要有node.js和npm以及hexo环境的。那只需要将备份的元数据clone到你想要的位置。  </p><p>执行:  </p><pre><code>$ npm install</code></pre><blockquote><p>然后更新文章，继续使用这个脚本来使得hexo变得更为轻松！</p><p>事实证明，这样的方式暂时是没有什么问题的。并且非常的方便！</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h2&gt;&lt;p&gt;因为本博客是基于Hexo+GitHub-Pages,所以在&lt;code&gt;hexo -d&lt;/code&gt;后生成的静态文件都存放于github，所以这是不用担心的。本地的hexo博客的源文件内存放着大量的文章markdown文件,所以问题来了。如果换电脑或者硬件损坏，或者有在其他机器更新文章的需求。就需要做一件事情就是将源文件，也就是本地hexo博客源文件的根目录整个备份。&lt;/p&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="http://git66.com/tags/hexo/"/>
    
      <category term="shell" scheme="http://git66.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>罪恶的起源，git初识</title>
    <link href="http://git66.com/2017/09/02/git-0/"/>
    <id>http://git66.com/2017/09/02/git-0/</id>
    <published>2017-09-02T01:46:00.000Z</published>
    <updated>2018-03-06T15:15:56.497Z</updated>
    
    <content type="html"><![CDATA[<h2 id="git和svn的区别"><a href="#git和svn的区别" class="headerlink" title="git和svn的区别"></a>git和svn的区别</h2><ul><li>SVN、cvs集中式的版本控制系统  </li><li>Git是分布式版本控制系统</li></ul><h2 id="git安装"><a href="#git安装" class="headerlink" title="git安装"></a>git安装</h2><p>Linux 尝试输入git可查看是否安装，如果未安装按照提示安装</p><p>windows直接官网下桌面版</p><p>安装完成后，还需要最后一步设置，在命令行输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;Your Name&quot;</span><br><span class="line">$ git config --global user.email &quot;email@example.com&quot;</span><br></pre></td></tr></table></figure><p>因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址</p><p>注意git config命令的–global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p><h2 id="创建版本仓库"><a href="#创建版本仓库" class="headerlink" title="创建版本仓库"></a>创建版本仓库</h2><blockquote><p>什么是版本库呢？版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。  </p></blockquote><a id="more"></a>  <p>创建一个版本库非常简单，首先，选择一个合适的地方，创建一个空目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir learngit</span><br><span class="line">$ cd learngit</span><br><span class="line">$ pwd</span><br><span class="line">/Users/michael/learngit</span><br></pre></td></tr></table></figure><p>pwd命令用于显示当前目录</p><p><strong>Windows系统，为了避免遇到各种莫名其妙的问题，请确保目录名（包括父目录）不包含中文。</strong>  </p><p>第二步，通过git init命令把这个目录变成Git可以管理的仓库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br><span class="line">Initialized empty Git repository in /Users/michael/learngit/.git/</span><br></pre></td></tr></table></figure><p>当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏</p><p>如果没有看到.git目录，那是因为这个目录默认是隐藏的，用ls -ah命令就可以看见。</p><p>在当前目录中添加任意文件：readme.txt(示例而已)</p><p>将文件添加到仓库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt</span><br></pre></td></tr></table></figure></p><p>将文件提交仓库中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &quot;wrote a readme file&quot;</span><br><span class="line">[master (root-commit) cb926e7] wrote a readme file</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 readme.txt</span><br></pre></td></tr></table></figure><h2 id="一些常用命令"><a href="#一些常用命令" class="headerlink" title="一些常用命令"></a>一些常用命令</h2><p>修改了文件<code>git status</code>查看状态    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line"># On branch master</span><br><span class="line"># Changes not staged for commit:</span><br><span class="line">#   (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">#   (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">#</span><br><span class="line">#    modified:   readme.txt</span><br><span class="line">#</span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure><p><code>git status</code>命令可以让我们时刻掌握仓库当前的状态，上面的命令告诉我们，readme.txt被修改过了，但还没有准备提交的修改。</p><p><code>git diff</code>查看具体修改的内容差异</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git diff readme.txt </span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">index 46d49bf..9247db6 100644</span><br><span class="line">--- a/readme.txt</span><br><span class="line">+++ b/readme.txt</span><br><span class="line">@@ -1,2 +1,2 @@</span><br><span class="line">-Git is a version control system.</span><br><span class="line">+Git is a distributed version control system.</span><br><span class="line"> Git is free software.</span><br></pre></td></tr></table></figure><h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><p><code>git log</code>命令显示从最近到最远的提交日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit 3628164fb26d48395383f8f31179f24e0882e1e0</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Tue Aug 20 15:11:49 2013 +0800</span><br><span class="line"></span><br><span class="line">    append GPL</span><br><span class="line"></span><br><span class="line">commit ea34578d5496d7dd233c827ed32a8cd576c5ee85</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Tue Aug 20 14:53:12 2013 +0800</span><br><span class="line"></span><br><span class="line">    add distributed</span><br><span class="line"></span><br><span class="line">commit cb926e7ea50ad11b8f9e909c05226233bf755030</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Mon Aug 19 17:51:55 2013 +0800</span><br><span class="line"></span><br><span class="line">    wrote a readme file</span><br></pre></td></tr></table></figure><p><code>git log --pretty=oneline</code>显示简略信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git log --pretty=oneline</span><br><span class="line">3628164fb26d48395383f8f31179f24e0882e1e0 append GPL</span><br><span class="line">ea34578d5496d7dd233c827ed32a8cd576c5ee85 add distributed</span><br><span class="line">cb926e7ea50ad11b8f9e909c05226233bf755030 wrote a readme file</span><br></pre></td></tr></table></figure><blockquote><p>类似3628164…882e1e0的是commit id（版本号），和SVN不一样，Git的commit id不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示，而且你看到的commit id和我的肯定不一样，以你自己的为准。为什么commit id需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。</p></blockquote><p>回退上一个版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br></pre></td></tr></table></figure><p>回退上一个的上一个版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^^</span><br></pre></td></tr></table></figure></p><p>版本多了就</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD~100</span><br></pre></td></tr></table></figure><p>通过commit id回退版本或回到最新版</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard 3628164</span><br></pre></td></tr></table></figure><p>版本号没必要写全，前几位就可以了，Git会自动去找。</p><p>Git的版本回退速度非常快，因为Git在内部有个指向当前版本的HEAD指针，当你回退版本的时候，Git仅仅是把HEAD从指向你回退的版本</p><blockquote><p>现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的commit id怎么办？</p></blockquote><p>Git提供了一个命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure></p><p>用来记录你的每一次命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog</span><br><span class="line">ea34578 HEAD@&#123;0&#125;: reset: moving to HEAD^</span><br><span class="line">3628164 HEAD@&#123;1&#125;: commit: append GPL</span><br><span class="line">ea34578 HEAD@&#123;2&#125;: commit: add distributed</span><br><span class="line">cb926e7 HEAD@&#123;3&#125;: commit (initial): wrote a readme file</span><br></pre></td></tr></table></figure><p>这样可以找到某个版本的commit id了</p><h2 id="工作区与暂存区"><a href="#工作区与暂存区" class="headerlink" title="工作区与暂存区"></a>工作区与暂存区</h2><p>操作git的目录就是工作区</p><p>版本库：<br>在git init时，会在当前工作区目录下生成.git目录。这不属于工作区的，而属于Git版本库</p><p>Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。</p><p><img src="https://www.liaoxuefeng.com/files/attachments/001384907702917346729e9afbf4127b6dfbae9207af016000/0" alt="image"></p><p>把文件往Git版本库里添加的时候，是分两步执行的：</p><p>第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区；</p><p>第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。</p><h2 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h2><p><code>git checkout -- file</code>可以丢弃工作区的修改： </p><p>一种是文件自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p><p>一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p><p>总之，就是让这个文件回到最近一次git commit或git add时的状态。</p><h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><p>从版本库中删除<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm file</span><br></pre></td></tr></table></figure></p><p>提交</p><h2 id="远程仓库（github）"><a href="#远程仓库（github）" class="headerlink" title="远程仓库（github）"></a>远程仓库（github）</h2><p>第1步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有<code>id_rsa</code>和<code>id_rsa.pub</code>这两个文件，如果已经有了，可直接跳到下一步。<br>如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</span><br></pre></td></tr></table></figure><p>id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。</p><p>第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面：</p><p>然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容</p><p>为什么GitHub需要SSH Key呢？  </p><p>因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送</p><h2 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h2><p>1.在github上创建空仓库</p><p>2.关联本地仓库与远程仓库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin git@github.com:youname/learngit.git</span><br></pre></td></tr></table></figure></p><p>3.初次推送本地仓库的内容到远程仓库中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git push -u origin master</span><br><span class="line">Counting objects: 19, done.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (19/19), done.</span><br><span class="line">Writing objects: 100% (19/19), 13.73 KiB, done.</span><br><span class="line">Total 23 (delta 6), reused 0 (delta 0)</span><br><span class="line">To git@github.com:michaelliao/learngit.git</span><br><span class="line"> * [new branch]      master -&gt; master</span><br><span class="line">Branch master set up to track remote branch master from origin.</span><br></pre></td></tr></table></figure><p>4.往后的每次推送<code>$ git push origin master</code></p><h2 id="SSH警告"><a href="#SSH警告" class="headerlink" title="SSH警告"></a>SSH警告</h2><p>第一次使用Git的clone或者push命令连接GitHub时，会得到一个警告：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The authenticity of host &apos;github.com (xx.xx.xx.xx)&apos; can&apos;t be established.</span><br><span class="line">RSA key fingerprint is xx.xx.xx.xx.xx.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)?</span><br></pre></td></tr></table></figure><p>输入yes回车即可。</p><h2 id="从远程仓库克隆"><a href="#从远程仓库克隆" class="headerlink" title="从远程仓库克隆"></a>从远程仓库克隆</h2><p><code>git clone</code>克隆一个本地库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/username/gitTest.git</span><br></pre></td></tr></table></figure><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><p>分支作用：</p><blockquote><p>假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。</p></blockquote><p>一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点：  </p><p><img src="https://www.liaoxuefeng.com/files/attachments/0013849087937492135fbf4bbd24dfcbc18349a8a59d36d000/0" alt="image">    </p><p>每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长：  </p><p>当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/001384908811773187a597e2d844eefb11f5cf5d56135ca000/0" alt="image"></p><p>Git创建一个分支很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化！</p><p>不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/0013849088235627813efe7649b4f008900e5365bb72323000/0" alt="image"></p><p>假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并： </p><p><img src="https://www.liaoxuefeng.com/files/attachments/00138490883510324231a837e5d4aee844d3e4692ba50f5000/0" alt="image"> </p><p>合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支：</p><p>创建dev分支，然后切换到dev分支：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev</span><br><span class="line">Switched to a new branch &apos;dev&apos;</span><br></pre></td></tr></table></figure><p><code>git checkout</code>命令加上-b参数表示创建并切换，相当于以下两条命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch dev</span><br><span class="line">$ git checkout dev</span><br><span class="line">Switched to branch &apos;dev&apos;</span><br></pre></td></tr></table></figure><p>用<code>git branch</code>命令查看当前分支：<br>*号为当前分支<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br></pre></td></tr></table></figure></p><h2 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h2><p>git merge命令用于合并指定分支到当前分支。所以合并前先切换需要合并的分支之外的分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git merge dev</span><br><span class="line">Updating d17efd8..fec145a</span><br><span class="line">Fast-forward</span><br><span class="line"> readme.txt |    1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><p>Fast-forward 表示是快速合并</p><h2 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d dev</span><br><span class="line">Deleted branch dev (was fec145a).</span><br></pre></td></tr></table></figure><p>小结</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Git鼓励大量使用分支：</span><br><span class="line"></span><br><span class="line">查看分支：git branch</span><br><span class="line"></span><br><span class="line">创建分支：git branch &lt;name&gt;</span><br><span class="line"></span><br><span class="line">切换分支：git checkout &lt;name&gt;</span><br><span class="line"></span><br><span class="line">创建+切换分支：git checkout -b &lt;name&gt;</span><br><span class="line"></span><br><span class="line">合并某分支到当前分支：git merge &lt;name&gt;</span><br><span class="line"></span><br><span class="line">删除分支：git branch -d &lt;name&gt;</span><br></pre></td></tr></table></figure><h2 id="合并分支的冲突处理"><a href="#合并分支的冲突处理" class="headerlink" title="合并分支的冲突处理"></a>合并分支的冲突处理</h2><p>合并分支时如果有冲突，在当前分支修改后提交，删除要合并的分支</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;git和svn的区别&quot;&gt;&lt;a href=&quot;#git和svn的区别&quot; class=&quot;headerlink&quot; title=&quot;git和svn的区别&quot;&gt;&lt;/a&gt;git和svn的区别&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;SVN、cvs集中式的版本控制系统  &lt;/li&gt;
&lt;li&gt;Git是分布式版本控制系统&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;git安装&quot;&gt;&lt;a href=&quot;#git安装&quot; class=&quot;headerlink&quot; title=&quot;git安装&quot;&gt;&lt;/a&gt;git安装&lt;/h2&gt;&lt;p&gt;Linux 尝试输入git可查看是否安装，如果未安装按照提示安装&lt;/p&gt;
&lt;p&gt;windows直接官网下桌面版&lt;/p&gt;
&lt;p&gt;安装完成后，还需要最后一步设置，在命令行输入：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git config --global user.name &amp;quot;Your Name&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git config --global user.email &amp;quot;email@example.com&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址&lt;/p&gt;
&lt;p&gt;注意git config命令的–global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。&lt;/p&gt;
&lt;h2 id=&quot;创建版本仓库&quot;&gt;&lt;a href=&quot;#创建版本仓库&quot; class=&quot;headerlink&quot; title=&quot;创建版本仓库&quot;&gt;&lt;/a&gt;创建版本仓库&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;什么是版本库呢？版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。  &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="git" scheme="http://git66.com/tags/git/"/>
    
      <category term="版本控制" scheme="http://git66.com/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>hexo+github pages搭建静态博客</title>
    <link href="http://git66.com/2017/09/01/hexo+github%20pages%20blog/"/>
    <id>http://git66.com/2017/09/01/hexo+github pages blog/</id>
    <published>2017-08-31T23:44:46.000Z</published>
    <updated>2018-03-06T15:15:56.497Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>使用github pages服务搭建博客的好处有：</p><ol><li>全是静态文件，访问速度快；</li><li>免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台；</li><li>可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的；</li><li>数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行；</li><li>博客内容可以轻松打包、转移、发布到其它平台；</li></ol><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ul><li>有一个github账号</li><li>安装了node.js、npm，并了解相关基础知识；</li><li>安装了git for windows（或者其它git客户端）</li></ul><h3 id="了解"><a href="#了解" class="headerlink" title="了解"></a>了解</h3><p>node作用：用来生成静态页面的 到Node.js官网下载相应平台的最新版本，一路安装即可。<br>git作用：把本地的hexo内容提交到github上去</p><h3 id="在github上搭建github-pages"><a href="#在github上搭建github-pages" class="headerlink" title="在github上搭建github pages"></a>在github上搭建github pages</h3><ul><li>新建一个名为<code>你的用户名.github.io</code>的仓库</li><li>之后的博客就存放于此  </li></ul><a id="more"></a>  <h3 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h3><p>域名配置最常见有2种方式，CNAME和A记录，CNAME填写域名，A记录填写IP，由于不带www方式只能采用A记录，所以必须先ping一下<code>你的用户名.github.io</code>的IP，然后到你的域名DNS设置页，将A记录指向你ping出来的IP，将CNAME指向<code>你的用户名.github.io</code>，这样可以保证无论是否添加www都可以访问，如下：</p><p><img src="http://oqr3htxnb.bkt.clouddn.com/17-9-2/43028527.jpg" alt=""></p><h3 id="配置本机的ssh-key-git"><a href="#配置本机的ssh-key-git" class="headerlink" title="配置本机的ssh key(git)"></a>配置本机的ssh key(git)</h3><h3 id="使用hexo写博客"><a href="#使用hexo写博客" class="headerlink" title="使用hexo写博客"></a>使用hexo写博客</h3><p>Hexo是一个简单、快速、强大的基于 Github Pages 的博客发布工具，支持Markdown格式，有众多优秀插件和主题。</p><p>官网： <a href="http://hexo.io" target="_blank" rel="noopener">http://hexo.io</a><br>github: <a href="https://github.com/hexojs/hexo" target="_blank" rel="noopener">https://github.com/hexojs/hexo</a></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo</span><br></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>在电脑的某个地方新建一个名为hexo的文件夹（名字可以随便取），比如我的是<code>F:\hexo</code>，由于这个文件夹将来就作为你存放代码的地方，所以最好不要随便放。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /f/Workspaces/hexo/</span><br><span class="line">$ hexo init</span><br></pre></td></tr></table></figure><p>hexo会自动下载一些文件到这个目录，包括node_modules，目录结构如下图：</p><p><img src="http://oqr3htxnb.bkt.clouddn.com/17-9-2/40428070.jpg" alt=""></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g || hexo generate <span class="comment"># 生成静态页面</span></span><br><span class="line">$ hexo s || hexo server  <span class="comment"># 启动服务本地预览</span></span><br></pre></td></tr></table></figure><p>执行以上命令之后，hexo就会在public文件夹生成相关html文件，这些文件将来都是要提交到github去的：</p><p><img src="http://oqr3htxnb.bkt.clouddn.com/17-9-2/94846888.jpg" alt=""></p><p><code>hexo s</code>是开启本地预览服务，打开浏览器访问 <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a></p><h3 id="关联github-pages"><a href="#关联github-pages" class="headerlink" title="关联github pages"></a>关联github pages</h3><p>打开博客根目录下的<code>_config.yml</code>文件,在最下方找到并照如下修改:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: https://github.com/StruggleYang/StruggleYang.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>执行命令，自动使用git部署：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>部署：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><p>在浏览器输入<code>user_name.github.io</code>,比如：</p><p><a href="http://struggleyang.github.io" target="_blank" rel="noopener">http://struggleyang.github.io</a></p><p>user_name是对应的github用户名</p><h3 id="以后的部署，按照以下三个步骤："><a href="#以后的部署，按照以下三个步骤：" class="headerlink" title="以后的部署，按照以下三个步骤："></a>以后的部署，按照以下三个步骤：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean  #清理public下的文件,建议使用，有时候不清理页面不生效</span><br><span class="line">hexo generate #生成静态文件</span><br><span class="line">hexo deploy #部署已经生成的静态文件</span><br></pre></td></tr></table></figure><h3 id="说个问题"><a href="#说个问题" class="headerlink" title="说个问题"></a>说个问题</h3><ul><li>为了保证访问，在绑定域名时对应的CNAME类型记录需要单独建立文件存放在网站根目录，CNAME放在source里面。</li><li>在之后的操作中每次更新文章都需要部署，所以有可能将CNAME文件被新版本清除</li></ul><h3 id="一些常用hexo命令："><a href="#一些常用hexo命令：" class="headerlink" title="一些常用hexo命令："></a>一些常用hexo命令：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;postName&quot; #新建文章</span><br><span class="line">hexo new page &quot;pageName&quot; #新建页面</span><br><span class="line">hexo generate #生成静态页面至public目录</span><br><span class="line">hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）</span><br><span class="line">hexo deploy #将.deploy目录部署到GitHub</span><br><span class="line">hexo help  #查看帮助</span><br><span class="line">hexo version  #查看Hexo的版本</span><br></pre></td></tr></table></figure><h3 id="一些可能用的路径"><a href="#一些可能用的路径" class="headerlink" title="一些可能用的路径:"></a>一些可能用的路径:</h3><p>文章在 source/_posts，编辑器可以用 Sublime，vscode，atom，有道云笔记，支持 markdown 语法。如果想修改头像可以直接在主题的 _config.yml 文件里面修改，友情链接，之类的都在这里，修改名字在 public/index.html 里修改</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;使用github pages服务搭建博客的好处有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;全是静态文件，访问速度快；&lt;/li&gt;
&lt;li&gt;免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台；&lt;/li&gt;
&lt;li&gt;可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的；&lt;/li&gt;
&lt;li&gt;数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行；&lt;/li&gt;
&lt;li&gt;博客内容可以轻松打包、转移、发布到其它平台；&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;准备工作&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;有一个github账号&lt;/li&gt;
&lt;li&gt;安装了node.js、npm，并了解相关基础知识；&lt;/li&gt;
&lt;li&gt;安装了git for windows（或者其它git客户端）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;了解&quot;&gt;&lt;a href=&quot;#了解&quot; class=&quot;headerlink&quot; title=&quot;了解&quot;&gt;&lt;/a&gt;了解&lt;/h3&gt;&lt;p&gt;node作用：用来生成静态页面的 到Node.js官网下载相应平台的最新版本，一路安装即可。&lt;br&gt;git作用：把本地的hexo内容提交到github上去&lt;/p&gt;
&lt;h3 id=&quot;在github上搭建github-pages&quot;&gt;&lt;a href=&quot;#在github上搭建github-pages&quot; class=&quot;headerlink&quot; title=&quot;在github上搭建github pages&quot;&gt;&lt;/a&gt;在github上搭建github pages&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;新建一个名为&lt;code&gt;你的用户名.github.io&lt;/code&gt;的仓库&lt;/li&gt;
&lt;li&gt;之后的博客就存放于此  &lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="http://git66.com/tags/hexo/"/>
    
      <category term="github-pages" scheme="http://git66.com/tags/github-pages/"/>
    
      <category term="blog" scheme="http://git66.com/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>安装Linux后我都做了哪些事？</title>
    <link href="http://git66.com/2017/07/10/installed%20Linux%20more/"/>
    <id>http://git66.com/2017/07/10/installed Linux more/</id>
    <published>2017-07-10T15:18:46.000Z</published>
    <updated>2018-03-06T15:15:56.498Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在使用了一段时间的Linux后，前前后后安装也有几十次，也犯过一些致命的错误，为了下次不再到处翻文档，现总结一些安装后必备的东西以及常用软件及操作，以便日后查阅！<br>备注一下：  </p></blockquote><p><strong>注意:请先阅读一遍全文后再操作，适用发行版为Ubuntu16.04及基于Ubuntu16.04构建的发行版，其他发行版部分相同或类似，不保证所有发行版的适用，其余发行版请自行Google对应教程，望悉知</strong>  </p><p><strong>发行版：elementary OS 0.4.1 Loki（基于 “Ubuntu 16.04.2 LTS” 构建）</strong></p><p><img src="http://oqr3htxnb.bkt.clouddn.com/17-5-30/29786706.jpg" alt=""></p><p><strong>警告:慎用rm命令，特别是root下的rm，或者带有-rf指令的rm</strong></p><a id="more"></a><h2 id="关于安装-Windows-10-elementary-OS-："><a href="#关于安装-Windows-10-elementary-OS-：" class="headerlink" title="关于安装(Windows 10 + elementary OS)："></a>关于安装(Windows 10 + elementary OS)：</h2><ul><li>对于安装而和ubuntu类似，大致有如下几个过程(只有大体过程，具体请自行百度)<ul><li>在win下用磁盘工具压缩出大致最小50G的盘(不格式化)</li><li>刻录发行版镜像到u盘(推荐‘软碟通’)</li><li>修改bios的启动(据电脑不同)</li><li>u盘启动进入安装，按照流程走就是了</li><li>重要的事是对于分区的选项，我大致是<ul><li>/boot- -逻辑 –400M</li><li>/ - -逻辑 –20G(因为/usr没有单独挂载，所以稍微大点)</li><li>swap –逻辑 –2G</li><li>/home –逻辑 –剩余全部</li></ul></li><li>安装完之后重启，会没有启动选项，进入win用esayBCD进行引导的修复添加</li></ul></li><li>以上事大致过程，并非教程，仅参考  </li></ul><h2 id="系统更新"><a href="#系统更新" class="headerlink" title="系统更新"></a>系统更新</h2><ul><li>进入系统做的第一件事情事联网，此发行版有很多驱动支持，并且基本都是可用的，不管事wifi还是以太，有了网络之后，你能做的事情就多了</li><li>联网后的第一件事情，安装系统更新：（因为考虑到速度尝试在这里找了国内的数据源进行替换，但是来更新数据源后很多东西找不到或者依赖有问题于是换了回来,所以建议使用默认源）  </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># sudo apt-get update</span><br><span class="line"># sudo apt-get upgrade</span><br><span class="line"># sudo apt-get dist-upgrade</span><br></pre></td></tr></table></figure><p> 上面的东西执行起来速度可能会很慢，但是这样的过程不会经常出现<br> 在商店对一些软件进行更新，并且安装显卡驱动等等，这些都是可视化的简单操作，这里不再累述</p><h2 id="一些常见问题"><a href="#一些常见问题" class="headerlink" title="一些常见问题"></a>一些常见问题</h2><p> 安装系统更新后你可能想安装一些软件了，但是我觉得你有必要进行如下的一些操作：</p><ul><li>这个是一个很常见的问题，win与linux的时间同步问题，大致就是时间相差7小时，现将这些杂碎的问题解决，再开始构建系统的应用</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># timedatectl set-local-rtc 1 --adjust-system-clock</span><br></pre></td></tr></table></figure><p> 有可能在第一次安装后执行此操作无效，你可以多试几次并重启</p><h2 id="安装vim"><a href="#安装vim" class="headerlink" title="安装vim"></a>安装vim</h2><p>为什么要安装vim，虽然系统已经有vi，但是易用性不是很强，vim是个不错的选择，而且对vi完全兼容，后面的操作里需要有它，所以先将他安装了，方便后面操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sudo apt-get vim</span><br></pre></td></tr></table></figure></p><p>vim的三种模式：</p><ul><li>一般模式（默认进入就是一般模式,一般模式时文件只读）</li><li>编辑模式（键盘‘i’键可进入，可以编辑文件，还有其他键【o, O, a, A, r, R】，ESC可退出）</li><li>命令模式（【 : / ? 】可进入，常见指令有q[退出]q![强制退出]wq[保存并退出]，其他的自行百度或者Google）</li></ul><h2 id="开机自动挂载ntfs磁盘"><a href="#开机自动挂载ntfs磁盘" class="headerlink" title="开机自动挂载ntfs磁盘"></a>开机自动挂载ntfs磁盘</h2><p>为什么要开机挂载磁盘？<br>假设一个场景，在某应用不得不需要引用windows的磁盘文件时，每次都会提示找不到路径，那你不得不在文件管理器中将其挂载。为了一劳永逸，并减少不必要的操作。所以建议此步执行，而这个挂载路径的方法使用于部分发行版但又有所不同，如Centos7系列的挂载可能需要安装NTFS3等等操作，具体内容还请Google。</p><p>挂载磁盘的基本思路事找到win下对应磁盘的设备号,将其<br>查看磁盘号，找到type为ntfs磁盘对应的设备号，再根据设备的具体类型大小和LABEL来找到平常对应的挂载路径，再修改设置使其长期挂载。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sudo fdisk -l</span><br></pre></td></tr></table></figure></p><p>下面是我的磁盘：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Disk /dev/sda: 465.8 GiB, 500107862016 bytes, 976773168 sectors</span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 4096 bytes</span><br><span class="line">I/O size (minimum/optimal): 4096 bytes / 4096 bytes</span><br><span class="line">Disklabel type: dos</span><br><span class="line">Disk identifier: 0x98eae607</span><br><span class="line">设备       启动     Start    末尾    扇区   Size Id 类型</span><br><span class="line">/dev/sda1  *           63 125837144 125837082    60G  7 HPFS/NTFS/exFAT</span><br><span class="line">/dev/sda2       125837310 976771071 850933762 405.8G  f W95 扩展 (LBA)</span><br><span class="line">/dev/sda5       125837312 335552511 209715200   100G  7 HPFS/NTFS/exFAT</span><br><span class="line">/dev/sda6       335552576 671096768 335544193   160G  7 HPFS/NTFS/exFAT</span><br><span class="line">/dev/sda7       671100928 850939903 179838976  85.8G  7 HPFS/NTFS/exFAT</span><br><span class="line">/dev/sda8       850941952 890939391  39997440  19.1G 83 Linux</span><br><span class="line">/dev/sda9       890941440 891719679    778240   380M 83 Linux</span><br><span class="line">/dev/sda10      891721728 893720575   1998848   976M 82 Linux 交换 / Solaris</span><br><span class="line">/dev/sda11      893722624 976771071  83048448  39.6G 83 Linux</span><br></pre></td></tr></table></figure></p><p>如现sda1,5,6,7根据大小可以判断其分别对应的win下C,D,E,F盘，并且最后可看出类型事ntfs格式磁盘<br>现查看磁盘的id及挂载名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sudo blkid</span><br></pre></td></tr></table></figure></p><p>结果  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/dev/sda1: UUID=&quot;8E5691D85691C17F&quot; TYPE=&quot;ntfs&quot; PARTUUID=&quot;98eae607-01&quot;</span><br><span class="line">/dev/sda5: LABEL=&quot;Apps&quot; UUID=&quot;20869BF2869BC6A6&quot; TYPE=&quot;ntfs&quot; PARTUUID=&quot;98eae607-05&quot;</span><br><span class="line">/dev/sda6: LABEL=&quot;Docs&quot; UUID=&quot;A040A29940A275A6&quot; TYPE=&quot;ntfs&quot; PARTUUID=&quot;98eae607-06&quot;</span><br><span class="line">/dev/sda7: LABEL=&quot;Project&quot; UUID=&quot;0A38BD1838BD042B&quot; TYPE=&quot;ntfs&quot; PARTUUID=&quot;98eae607-07&quot;</span><br><span class="line">/dev/sda8: UUID=&quot;2a816ddd-f925-442c-8b4c-cc7fd76545b9&quot; TYPE=&quot;ext4&quot; PARTUUID=&quot;98eae607-08&quot;</span><br><span class="line">/dev/sda9: UUID=&quot;74e2bc02-59fc-4517-ae95-18ec46541d9d&quot; TYPE=&quot;ext4&quot; PTTYPE=&quot;dos&quot; PARTUUID=&quot;98eae607-09&quot;</span><br><span class="line">/dev/sda10: UUID=&quot;eb8aded8-9282-426e-9b86-7333bde0d0fe&quot; TYPE=&quot;swap&quot; PARTUUID=&quot;98eae607-0a&quot;</span><br><span class="line">/dev/sda11: UUID=&quot;421078a4-af25-4fa4-a474-b250e0943c0e&quot; TYPE=&quot;ext4&quot; PARTUUID=&quot;98eae607-0b&quot;</span><br></pre></td></tr></table></figure><p>修改配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sudo vim /etc/fstab</span><br></pre></td></tr></table></figure></p><p>i进入插入模式在后面添加：<br>注：sy是我的用户名，在media文件夹下你也可以看到你对应的文件夹<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># disk for Windows10</span><br><span class="line"># c:  for windows10</span><br><span class="line">#/dev/sda1       /media/sy/System                ntfs    defaults        0       0</span><br><span class="line"># D:  for windows10</span><br><span class="line">/dev/sda5       /media/sy/Apps                  ntfs    defaults        0       0</span><br><span class="line"># E:  for windows10</span><br><span class="line">/dev/sda6       /media/sy/Docs                     ntfs    defaults        0       0</span><br><span class="line"># F:  for windows10</span><br><span class="line">/dev/sda7       /media/sy/Project                  ntfs    defaults        0       0</span><br></pre></td></tr></table></figure></p><p>上面有三个磁盘挂载，C盘我不希望（怕误删了windows下的重要文件）自动挂载所以给注释了。而每个磁盘对应着六个参数其意思分别是：（从左到右）</p><ul><li><code>&lt;file system&gt;</code> ：分区定位，可以给磁盘号，UUID或LABEL，例如：/dev/sda2，UUID=6E9ADAC29ADA85CD或LABEL=Docs</li><li><code>&lt;mount point&gt;</code> : 具体挂载点的位置，例如：/media/userName/C</li><li><code>&lt;type&gt;</code> : 挂载磁盘类型，linux分区一般为ext4，windows分区一般为ntfs</li><li><code>&lt;options&gt;</code>: 挂载参数，一般为defaults</li><li><code>&lt;dump&gt;</code> : 磁盘备份，默认为0，不备份</li><li><code>&lt;pass&gt;</code>: 磁盘检查，默认为0，不检查</li></ul><blockquote><p>在这里我发现一个问题就是，NTFS对应的LABEL在windows下对应磁盘的名称，所以建议在windows下使用英文命名磁盘名称</p></blockquote><p>以上操作完成后保存并退出vim，在终端输入以下检查并挂载新添项：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sudo mount -a</span><br></pre></td></tr></table></figure></p><p>mount -a会/etc/fstab中的项全部挂载，如果有错，则会提示错误，然后根据错误找出原因修改。</p><blockquote><p>如果说某个磁盘没有找到，先查看是否在文件管理器已经将其挂载，因为在检查时会因为没有挂载而找不到，将所有磁盘挂载后再次执行即可。</p></blockquote><p><strong>注意：千万不要挂载到当前用户的根目录，因为挂载的分区会覆盖当前分区内容,那有可能将是一个致命的操作</strong></p><h2 id="安装Gdebi以方便安装deb软件包"><a href="#安装Gdebi以方便安装deb软件包" class="headerlink" title="安装Gdebi以方便安装deb软件包"></a>安装Gdebi以方便安装deb软件包</h2><p>两中方式安装：</p><ul><li>在应用商店找到并安装</li><li>通过<code>sudo apt-get install gdebi</code>安装</li></ul><h2 id="安装搜狗输入法"><a href="#安装搜狗输入法" class="headerlink" title="安装搜狗输入法"></a>安装搜狗输入法</h2><p>现在的你可能需一个中文输入法对一些问题进行描述和记录，那么它来了<br>安装搜狗输入法是一个简单的过程，但是会需要安装一些依赖步骤如下：</p><ul><li>添加fcitx的键盘输入法系统，因为sogou是基于fcitx的，而系统默认的是iBus；</li><li>安装sogou输入法；</li><li>设置系统参数及一些注意点。</li></ul><p>先添加以下源<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sudo add-apt-repository ppa:fcitx-team/nightly</span><br></pre></td></tr></table></figure></p><blockquote><p>如果提示源找不到依此执行安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># sudo apt-get install python-software-properties</span><br><span class="line"># sudo apt-get install software-properties-common</span><br><span class="line"># sudo apt-get update</span><br></pre></td></tr></table></figure></p></blockquote><p>添加源之后需要更新一下系统<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sudo apt-get update</span><br></pre></td></tr></table></figure></p><p>开始安装fcitx<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sudo apt-get install fcitx</span><br></pre></td></tr></table></figure></p><p>下载搜狗输入法安装包（官网地址）：</p><p><a href="http://pinyin.sogou.com/linux/?r=pinyin" target="_blank" rel="noopener">http://pinyin.sogou.com/linux/?r=pinyin</a><br>下载完毕在文件管理器中用Gdebi打开并安装。<br>或者在软件包对应的目录（文件名要对应修改）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sudo gdebi sogoupinyin.deb</span><br></pre></td></tr></table></figure></p><h2 id="安装另一些常用软件"><a href="#安装另一些常用软件" class="headerlink" title="安装另一些常用软件"></a>安装另一些常用软件</h2><p>在这里这些常用软件都是deb包的，所以安装过程不再累述，安装只需要gdebi打开就行，或者在命令行进行安装</p><blockquote><p>还有一点注意的事，就是deb包用gdebi安装时会自动将其依赖的包下载安装，所以一些软件你不必去担心他的依赖</p></blockquote><p>下面列出常用的一些可以通过deb软件包程序安装的日常软件：</p><ul><li>Google Chrome（我只用这个浏览器）</li><li>wps（国产免费还支持Linux，支持，这样办公所需就有了）</li><li>网易云音乐（抖腿之道，唯有网易）</li><li>Aotm（前端开发很好用，不过我发现写MarkDown也很好用，此篇就是这货写的）<blockquote><p>以上软件deb包都可以在对应的官网进行下载</p></blockquote></li></ul><p>还有一些可以在应用商店下载安装的程序：</p><ul><li>FileZilla（ftp传输真的很方便）</li><li>系统监视器（日常看资源占用）</li><li>还有其他的一些自己去探索吧</li></ul><h2 id="开发环境搭建（Java-JavaWeb-Android）"><a href="#开发环境搭建（Java-JavaWeb-Android）" class="headerlink" title="开发环境搭建（Java||JavaWeb||Android）"></a>开发环境搭建（Java||JavaWeb||Android）</h2><p>上面做的只是对于日常使用而做的一些安装和配置，对于程序员来讲，要发挥桌面版的Linux的最大作用还差这些东西，现简要列出来：</p><ul><li>MySQL</li><li>JDK</li><li>Maven</li><li>Tomcat</li><li>IDEA</li><li>科学上网</li></ul><h2 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h2><p>在ubuntu（elementary OS）下安装MySQL是一件简单的事情，只需要执行以下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sudo apt-get install mysql-server</span><br></pre></td></tr></table></figure><p>安装过程中会让你设定两次mysql的root密码，输完请按tab键到（ok）确定，并继续</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># sudo apt-get install mysql-client</span><br><span class="line"></span><br><span class="line"># sudo apt-get install libmysqlclient-dev</span><br></pre></td></tr></table></figure><p>安装完成后用以下命令来检验是否安装成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sudo netstat -tap|grep mysql</span><br></pre></td></tr></table></figure><p>通过上述命令检查后如果看到mysql的socket处于listen状态则表示安装成功</p><p>登陆mysql检验：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># mysql -u root -p</span><br></pre></td></tr></table></figure></p><p>键入刚才设置的密码以检验。</p><h2 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h2><p>卸载openjdk:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sudo apt-get purge openjdk*</span><br></pre></td></tr></table></figure><p>官网:<a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/index.html</a><br>下载官方jdk（如：jdk-8u102-linux-x64.tar.gz）<br>创建JDK存放路径。我的JDK存放在“/usr/jdk”，所以使用命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sudo mkdir /usr/jdk</span><br></pre></td></tr></table></figure></p><p>复制jdk-8u102-linux-x64.tar.gz文件到/usr/jdk，且使用解压缩命令“tar zxvf”解压缩<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># cd /usr/jdk</span><br><span class="line">// 到要存放jdk的目录(假设文件在下载目录)</span><br><span class="line"># sudo mv /home/×××/Downloads/jdk-8u102-linux-x64.tar.gz ./</span><br><span class="line">// 表示将压缩包移动到当前目录下，注意命令的目录</span><br><span class="line"># sudo tar -zxvf jdk-8u102-linux-x64.tar.gz</span><br><span class="line">// 解压到当前目录</span><br></pre></td></tr></table></figure></p><blockquote><p>环境变量配置:  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/profile</span><br></pre></td></tr></table></figure><p>这时会打开文件，在最后添加：(如果安装路径改变请对应修改)  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/jdk/jdk1.8.0_102</span><br><span class="line">export JRE_HOME=/usr/jdk/jdk1.8.0_102/jre</span><br><span class="line">export CLASSPATH=.:$CLASSPATH:$JAVA_HOME/lib:$JRE_HOME/lib</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin</span><br></pre></td></tr></table></figure><p>添加完成保存关闭，回到终端输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># source /etc/profile</span><br></pre></td></tr></table></figure></p><p>输入java或javac检验</p><h2 id="安装Maven"><a href="#安装Maven" class="headerlink" title="安装Maven"></a>安装Maven</h2><p>这个东西直接参考Maven官网就可以操作完成了  </p><p>官网地址：<a href="http://maven.apache.org/" target="_blank" rel="noopener">http://maven.apache.org/</a>  </p><p>一般情况下提供tar.gz包和zip包  </p><p>安装maven的先决条件是JDK哟</p><p>假设下载下来的是tar.gz包:<code>apache-maven-3.5.0-bin.tar.gz</code><br>将其存放到你想安装的目录，在存放目录下执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sudo tar -zxvf apache-maven-3.5.0-bin.tar.gz</span><br></pre></td></tr></table></figure></p><p>现假设Maven被安装在/usr/maven目录下：（此操作将其加入环境变量但只是暂时的）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># export PATH=/usr/maven/apache-maven-3.5.0/bin:$PATH</span><br></pre></td></tr></table></figure></p><p>环境变量永久生效:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sudo vim /etc/profile</span><br></pre></td></tr></table></figure><p>加入以下变量：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#maven</span><br><span class="line">export MAVEN_HOME=/usr/maven/apache-maven-3.5.0</span><br><span class="line">export PATH=$&#123;PATH&#125;:$&#123;MAVEN_HOME&#125;/bin</span><br></pre></td></tr></table></figure><p>wq退出后刷新使环境变量生效<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># source /etc/profile</span><br></pre></td></tr></table></figure></p><p>检验安装:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn -v</span><br></pre></td></tr></table></figure></p><p>正确输出:(类似就行，不必一样)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Apache Maven 3.5.0 (ff8f5e7444045639af65f6095c62210b5713f426; 2017-04-04T03:39:06+08:00)</span><br><span class="line">Maven home: /usr/maven/apache-maven-3.5.0</span><br><span class="line">Java version: 1.8.0_131, vendor: Oracle Corporation</span><br><span class="line">Java home: /usr/jdk8/jdk1.8.0_131/jre</span><br><span class="line">Default locale: zh_CN, platform encoding: UTF-8</span><br><span class="line">OS name: &quot;linux&quot;, version: &quot;4.4.0-83-generic&quot;, arch: &quot;amd64&quot;, family: &quot;unix&quot;</span><br></pre></td></tr></table></figure></p><h2 id="安装Tomcat"><a href="#安装Tomcat" class="headerlink" title="安装Tomcat"></a>安装Tomcat</h2><p>Tomcat安装与上面几个安装是类似的：</p><p>官网:<a href="http://tomcat.apache.org/" target="_blank" rel="noopener">http://tomcat.apache.org/</a>  </p><p>下载tar.gz包，不再累述复制和解压过程，请参照以上两个解压过程</p><p>现假设下载tomcat7被解压安装到了<code>/usr/tomcat7/</code>下：</p><p>先将tomcat文件夹及子文件权限改到任意人读写执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sudo chmod -R a+rwx  /usr/tomcat7/*</span><br></pre></td></tr></table></figure><p>找到bin目录:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># cd /usr/tomcat7/apache-tomcat-7.0.73/bin</span><br></pre></td></tr></table></figure></p><p>启动:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># ./startup.sh</span><br></pre></td></tr></table></figure></p><p>提示jdk环境问题:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sudo vim catalina.sh</span><br></pre></td></tr></table></figure></p><p>加入JDK的环境变量:（请相应改变）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/jdk8/jdk1.8.0_131</span><br><span class="line">export JRE_HOME=/usr/jdk8/jdk1.8.0_131/jre</span><br></pre></td></tr></table></figure></p><p>正确输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Using CATALINA_BASE:   /usr/tomcat7/apache-tomcat-7.0.79</span><br><span class="line">Using CATALINA_HOME:   /usr/tomcat7/apache-tomcat-7.0.79</span><br><span class="line">Using CATALINA_TMPDIR: /usr/tomcat7/apache-tomcat-7.0.79/temp</span><br><span class="line">Using JRE_HOME:        /usr/jdk8/jdk1.8.0_131/jre</span><br><span class="line">Using CLASSPATH:       /usr/tomcat7/apache-tomcat-7.0.79/bin/bootstrap.jar:/usr/tomcat7/apache-tomcat-7.0.79/bin/tomcat-juli.jar</span><br><span class="line">Tomcat started.</span><br></pre></td></tr></table></figure></p><p>停止:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./shutdown.sh</span><br></pre></td></tr></table></figure><h2 id="安装IDEA"><a href="#安装IDEA" class="headerlink" title="安装IDEA"></a>安装IDEA</h2><p>IDEA的安装过程没有多大变化，下载解压即可使用。</p><p>官网：<a href="http://www.jetbrains.com/idea/" target="_blank" rel="noopener">http://www.jetbrains.com/idea/</a>  </p><p>除了IDEA很多jetbrains家族的东西都是很好用的，在Linux平台也有很好的更新支持</p><p>如果是Android开发者，android studio也会很容易兼容此系统</p><h2 id="科学上网"><a href="#科学上网" class="headerlink" title="科学上网"></a>科学上网</h2><p><del>关于科学上网，我是用的奇影shadowsocks。一般我也用的不多，同步Chrome书签和插件时，找找Google时会用用！</del></p><h2 id="一些预览"><a href="#一些预览" class="headerlink" title="一些预览"></a>一些预览</h2><p><img src="http://oqr3htxnb.bkt.clouddn.com/17-5-30/40219153.jpg" alt=""></p><p><img src="http://oqr3htxnb.bkt.clouddn.com/17-5-30/94337476.jpg" alt=""></p><blockquote><p>还有很多有趣的东西自己去探索吧。此文为迁移博文。之前发表于=&gt;<a href="http://blog.csdn.net/godevelop/article/details/74937795" target="_blank" rel="noopener">我的CSDN</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在使用了一段时间的Linux后，前前后后安装也有几十次，也犯过一些致命的错误，为了下次不再到处翻文档，现总结一些安装后必备的东西以及常用软件及操作，以便日后查阅！&lt;br&gt;备注一下：  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意:请先阅读一遍全文后再操作，适用发行版为Ubuntu16.04及基于Ubuntu16.04构建的发行版，其他发行版部分相同或类似，不保证所有发行版的适用，其余发行版请自行Google对应教程，望悉知&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;发行版：elementary OS 0.4.1 Loki（基于 “Ubuntu 16.04.2 LTS” 构建）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://oqr3htxnb.bkt.clouddn.com/17-5-30/29786706.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;警告:慎用rm命令，特别是root下的rm，或者带有-rf指令的rm&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://git66.com/tags/linux/"/>
    
      <category term="ubuntu" scheme="http://git66.com/tags/ubuntu/"/>
    
  </entry>
  
</feed>
